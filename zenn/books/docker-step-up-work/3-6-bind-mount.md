---
title: "３部: バインド・マウント"
---

バインド・マウントもボリュームと同じくコンテナのデータをホストマシンと共有する方法です。

このページでは使い方と使い分けについて学びます。

![image](/images/structure/structure.080.jpeg)

# このページでやること
- App コンテナ
  - 起動コマンドをバインド・マウントを使うように修正
- DB コンテナ
    - 起動コマンドをバインド・マウントを使うように修正

# このページで初登場するコマンドとオプション

# バインド・マウントとは
バインド・マウントは **ホストマシンの任意のディレクトリをコンテナにマウントする** 仕組みです。

**ホストマシンとコンテナ双方がファイルの変更に関心がある** という場合に有用で、たとえばソースコードの共有などに活用できます。

![image](/images/structure/structure.081.jpeg)

ソースコードのディレクトリをバインド・マウントしてホストマシン側と共有すれば、コードを変更した時に同期や転送が不要になります。

# バインド・マウントする
バインド・マウントはボリュームと違い **既存のディレクトリをそのままマウントする** ので、事前作成などはありません。

またバインド・マウントも `--volume` と `--mount` によるマウントが可能です。

## --volume によるマウント
バインドマウントを行う場合は、`:` で区切られた設定のうち１つめをパスにします。

適当な Ubuntu コンテナで確認します。

```:Host Machine
$ docker container run      \
  --name ubuntu1            \
  --rm                      \
  --interactive             \
  --tty                     \
  --volume $(pwd):/bind-dir \
  ubuntu:20.04              \
  bash

# ls bind-dir/
docker

# ls bind-dir/docker
app  db
```

`docker container run` をどこで実行したかにもよりますが、この例では `/bind-dir` にホストマシンで作成した `docker/app/Dockerfile` などが存在します。

コンテナ内で `hello.txt` を作成すると、ホストマシンでも確認できます。

```:Container
# touch bind-dir/hello.txt

# exit

$ ls                                                                                                                                                                                                    tmp
docker  hello.txt
```

## --mount によるマウント
バインド・マウントを行う場合は、`type` を変更するだけなので直感的に理解できます。

今度は App コンテナに `.php` をマウントして、PHP のコーディングをする準備を整えます。
PHP のデータは todo にあるものを取得してください。

マウント先はどこでも良いので、適当に `/src` にします。
またビルトインウェブサーバーのドキュメントルートを `/src` に合わせたいため、`<command>` に `-t` を追加します。

コンテナを起動します。

```:Host Machine
todo fetch
todo cd

$ docker container run                        \
    --interactive                             \
    --tty                                     \
    --name app                                \
    --rm                                      \
    --detach                                  \
    --mount type=bind,src=$(pwd)/src,dst=/src \
    docker-practice:app                       \
    php -S 0.0.0.0:8000 -t /src

$    
```

また `curl` がないのでさっとインストールします。
( Dockerfile を書いた時についでに入れておいてもよかったかもしれません。)

```:Host Machine
$ docker container exec  \
    --interactive        \
    --tty                \
    app                  \
    bash

# apt install curl
```

Web サーバにリクエストを送ると、ホストマシンに置いた `index.php` を使ったレスポンスが得られます。

```:Container
# curl -sS localhost:8000 | grep '<title>'

<title>Hello | Docker Practice</title>
```

ホストマシンの `index.php` を書き換えると、**コンテナ再起動をしなくても結果が変わる** ことを確認してください。

# バインド・マウントの実体と注意
実体は **そのままホストマシンのファイルシステム** です。

つまりバインド・マウントはボリュームと比べると **実体の面倒を見ているのが Docker ではなく自分** であり、それが **ホストマシン上** であることです。

「仮想環境だから」と安易に `rm -rf *` でもして、もしそこにバインド・マウントしたディレクトリが含まれていたら、**破壊はホストマシンに波及します**。

Docker の公式も **まずはボリュームを検討し、どうしてもだめならバインド・マウントを使え** と言っています。

大抵は Git などを使っているし、バインド・マウントも `/` を `/` にみたいな極端なことをしなければ危険は全然ありませんが、違いは正しく把握しておくと良いでしょう。

# まとめ
## ボリュームとバインドマウントの比較
ボリュームは次のような特徴があります。

- `docker volume create` で作成したボリュームをコンテナにマウントする
- ボリュームの実体は Linux 上のどこかであり **Docker に管理される**
- ホストマシンから **ボリュームにはアクセスしない**
- コンテナ内でどのような操作をしても **影響は Docker の管理する範囲内にとどまる**

バインド・マウントは次のような特徴があります。

- ホストマシンのファイルやディレクトリをコンテナにマウントする
- マウントするファイルやディレクトリは **Docker に管理されない**
- ホストマシンで Docker 以外のプロセスで **ファイルやディレクトリを変更して良い**
- コンテナ内でのファイル削除などが **ホストマシンに影響する**

## --volume と --mount の比較
`--volue` オプションは次のような特徴があります。

- 指定する順番が定まっている
- 短く書けるが知らないと読めない
- 1 つめの書き方によってボリュームかバインドマウントか決まる
  - ボリューム名の場合はボリューム
  - 絶対パスの場合はバインドマウント

`--mount` オプションは次のような特徴があります。

- 順番は自由
- 長くなるが読みやすい

## やったこと
- `.php` の取得
- App コンテナ
    - コンテナ起動時にバインド・マウントをする

## できるようになったこと
- App コンテナ
  - `.php` をホストマシンでコーディングできるようになった

![image](/images/structure/structure.080.jpeg)

## やりきれなかったこと
- 
