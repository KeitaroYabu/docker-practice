---
title: "２部: Docker を理解するためのポイント"
---

Docker の細かい話に入る前に、Docker を正しく、そして結果的には早く理解するために、まずはとても大切なポイントを４つ確認します。
( これは僕による分類で、あくまでこの本に限るものです )

1. 基本の要素は３つ
2. 基本のコマンドも３つ
3. コマンドの形を意識する
4. Docker と周辺ツールを分ける

Docker をコマンド一覧やオプション一覧から理解しようとすると、ちゃんと基本を身につけるのが極めて難しいと思います。
それは「起動するならこう」「こういうときはこう」「このエラーが出たらこう」のようにやみくもに集めた知識は、正しく自分の状況に当てはめることができないからです。

ただたくさんのコマンドを写経で実行して「ふーん...??」となるよりも、まずはちょっとの時間を割いて基本を堅実におさえることが絶対に近道です。

# 1. 基本の要素は３つ
Docker で開発環境を構築をする場合、実は出てくる要素はそんなに多くありません。
この本では次の３つを基本の要素として考えることにします。

1. コンテナ
2. イメージ
3. Dockerfile

![image](/images/structure/structure.001.jpeg)

:::message
この本では Docker が構築・管理してくれるものは 🐳 アイコンで、
開発者が自分で作成・管理する必要のあるものは 🍎 アイコンで、
それぞれ示すことにします。
:::

この本の後半では、コンテナ同士で通信できるようにするためにネットワークを作成したり、コンテナのデータをホストマシンと共有するためにボリュームを作成したりしますが、誤解を恐れずに言えばそれらの要素は基本の要素を脚色するものだと考えられます。

この３つの基本の要素を１つずつ理解していきしましょう。

## コンテナとは
todo の図にもある通り、コンテナは特定のコマンドを実行するために作られるホストマシンから隔離された領域です。

Docker に不慣れな間はコンテナをホストマシン上で動いている仮想 OS のように感じるかもしれませんが、コンテナの実態は Linux の Namespace という機能により他と分離されたただの１プロセスでしかありません。
Linux の Namespace 自体はもう 20 年近く存在する技術であり、それをコンテナやイメージというものを用いて扱いやすくした技術が Docker ということになります。

![image](/images/structure/structure.002.jpeg)

ホストマシンにも各コンテナにも Process ID 1 のプロセスや `/etc/hosts` などのファイルがあり重複していますが、Namespace により隔離された領域をマッピングすることで衝突を回避しています。

この Namespace をイメージから作り出すことで異なる OS に見えるようにしてくれたり、Namespace を簡単に作ったり消したりできるようなコマンドを提供してくれたりするものが Docker と言えます。

そう考えると todo で説明した「コンテナに OS は含まれておらず、ホストマシンのカーネルを使っている」ということが理解しやすいはずです。
コンテナはあくまでホストマシンの１プロセスであり、仮想サーバではないのです。

コンテナには次のような特徴があります。

1. コンテナはイメージをもとに作られる
1. Docker の CLI や API を使って、生成や起動や停止を行うことができる
1. 複数のコンテナは互いに独立していて影響できず、独自に動作する
1. Docker Engine の上ならローカルマシンでも仮想マシンでもクラウド環境でも動かせる

![image](/images/structure/structure.003.jpeg)

## イメージとは
イメージはコンテナの実行に必要なパッケージで、ファイルやメタ情報を集めたものです。

イメージは複数のレイヤーというものからなる情報のことであり、ホストマシンのどこかに `.img` のような具体的な単一のファイルが存在するわけではありません。

イメージにはレイヤーによって次のような情報が含まれています。

- ベースはなにか
- なにをインストールしてあるか
- 環境変数はどうなっているか
- どういう設定ファイルを配置しているか
- デフォルト命令はなにか

![image](/images/structure/structure.004.jpeg)

また、[Docker Hub](https://hub.docker.com/) に公開されているものがイメージです。
( Dockerfile ではありません。)

そのおかげで、たとえばチームで「`php8.1` のイメージを使う」と決めておけば、同じ開発環境を構築することが容易にできます。

![image](/images/structure/structure.005.jpeg)

## Dockerfile とは
Dockerfile は既存のイメージにレイヤーをさらに積み上げるために用いるテキストファイルです。

インターネット上に公開されているイメージではインストールしてあるコマンドが足りないなどの問題がある場合に、自分に都合の良いイメージを作るために Dockerfile を作成します。

![image](/images/structure/structure.006.jpeg)

イメージを作れと言われるととても難しそうですが、公開されているイメージに Dockerfile でレイヤーを乗せるだけなので、OS から構築したりする手間は不要でとても簡単です。

また、[GitHub](https://github.co.jp/) で共有するのは Dockerfile です。
( イメージではありません。)

それにより、たとえばチームで「`php8.1` のイメージに `git` を入れたイメージを使う」という構成を共有することができます。

![image](/images/structure/structure.007.jpeg)

# 2. 基本のコマンドも３つ
３つの要素を軸に考えると、誤解を恐れなければコマンドの基本形も３つに分類できると考えられます。

1. コンテナを起動する
2. イメージを作る
3. コンテナをどうにかする

図におこしたとしても、せいぜいこの程度しかありません。

![image](/images/structure/structure.008.jpeg)

この３つの基本のコマンドも１つずつ理解していきしましょう。
( それぞれの詳細は次以降のページで改めて解説します )

## コンテナを起動する
`docker container run` というコマンドは、**イメージ** から **コンテナを起動する** コマンドです。

![image](/images/structure/structure.009.jpeg)

`docker container run` には非常に多くのオプションがあり、コンテナの用途に応じて多量のオプションを使い分ける必要があります。
が、基礎中の基礎である **イメージからコンテナを１つ作るだけのコマンド** という点を忘れないようにしましょう。

この本でもそれなりの数のオプションは解説しますが、オプションは本当に多いので無理に覚えようとせずに、自分に必要なものを自分のタイミングで１つずつ理解していけば十分です。

また、実は `docker container run` は次のコマンドを一気に行う便利コマンドなのですが、この本ではコマンド個別の解説は行わずに `docker container run` として解説します。

- `docker image pull`
- `docker container create`
- `docker container start`

## イメージを作成する
`docker image build` というコマンドは、**Dockerfile** から **イメージを作成する** コマンドです。

![image](/images/structure/structure.010.jpeg)

先ほど解説した通り、Dockerfile はベースとなるイメージを指定し、「コマンドのインストール」や「設定ファイルの配置」などのレイヤーを重ねて、新たなイメージを作るためのものです。

そうして自分で作成したイメージは、他のイメージと全く同様に `docker container run` で使うことができます。

![image](/images/structure/structure.011.jpeg)

## コンテナを操作する
たとえば `docker container exec` は **コンテナ** に **命令を送る** コマンドです。

対象がコンテナなので、必然的に `docker container run` のあとに使うコマンドになります。
**イメージ** や **Dockerfile** に対しては命令できません。

![image](/images/structure/structure.012.jpeg)

`docker container exec` で「ログを見せろ」「テストを実行しろ」「DB に繋がせろ」のような命令を送ることで、起動しているコンテナに様々な処理をさせることができます。

他にも `docker container stop` という **コンテナ** を **停止する** コマンドなど、コンテナを対象になんらかを行うコマンドはたくさんあります。

# 3. コマンドの形を意識する
３つの基本の要素と３つの基本のコマンドを理解できたら、その基礎を最大限に活かすために「コマンドが **なに** を **どうする** のか」を常に考える習慣を作ります。

初めは大変で辛く感じるかもしれませんが、やみくもにコマンドを覚えるのとこれを続けるのでは、理解の早さと深さが圧倒的に違います。

この習慣を、頑張らずに楽に行えるようになったころが「Docker わかってきた気がする」という扉が開く瞬間のはずです。

## 「なに」を「どうする」か
３つの基本の要素と３つの基本のコマンドについて理解したところで、もう一度全体像を確認します。

![image](/images/structure/structure.008.jpeg)

矢印の先がコンテナなら `docekr container xxx` で、矢印の先がイメージなら `docker image xxx` になっていることがわかるはずです。
それが **なに** の部分です。

そして `run` や `build` の部分が **どうする** の部分です。

コマンド１つを実行するたびに脳内で ( もちろん紙でも ) この図が描ければ、すぐ理解が深まるはずです。

## 新コマンドと旧コマンドについて
普段から Docker を利用されている方はお気付きでしょうが、この本では `docker run` ではなく `docker container run` を使っています。

実は Docker のコマンドは 2017 年 1 月にリリースされた v1.13 で大幅な変更が行われており、`docker run` が旧コマンド、`docker container run` が新コマンドとなっています。
これは `docker run` や `docker build` のような `docker` 直下のコマンドが増えすぎて **なに** がわかりづらくなってしまったためで、v1.13 からはそれぞれ対象を明示できるサブコマンド形式の方を使うことが推奨されています。

![image](/images/picture/picture.027.jpeg)

普段目にするコマンドはおそらく `docker run` や `docker build` などの旧コマンドが多いのではないかと思います。
僕自身も短くて楽なので普段は旧コマンドを使っていますが、この本では **なに** が明瞭な新コマンドを使って説明を行います。

タイプ数は多くなりますが、どちらが理解しやすいかは一目瞭然ですね。

旧コマンド

- `docker build`
- `docker run`
- `docker pull`
- `docker create`
- `docker start`
- `docker images`
- `docker ps`

新コマンド

- `docker image build`
- `docker container run`
- `docker image pull`
- `docker container create`
- `docker container start`
- `docker image ls`
- `docker container ls`

# 4. Docker と周辺ツールを分ける
Docker を前提としたものがいくつかあるので、初学者のうちはそれを Docker そのものの基礎と混同しないように気を付けると良いでしょう。

1. Docker Compose
2. Kubernetes

ここでは２つだけ、軽く紹介します。

## Docker Compose
Docker Compose は `docker-compose.yml` という Yaml ファイルを書くことにより、目的の違う複数のコンテナをまとめて起動したり、複数の `docker xxx create` などを実行してくれるツールです。

![image](/images/picture/picture.018.jpeg)

Docker Compose は Docker Desktop に含まれており、`docker compose xxx` のようなコマンド体系になっています。

Docker CLI のみで環境を構築しようとすると、多量の複雑なコマンドを誰でも何度でも同じく実行できるためには **Docker コマンドの手順書が必要** になります。
この問題を、Docker Compose を使い詳細な命令は **全部 Yaml に書いて GitHub で共有** するという方法で解決することができるようになります。

![image](/images/picture/picture.019.jpeg)

Docker を使って開発環境を構築する todo エンジニアにとって、Docker Compose は必須のスキルと言えるでしょう。

この本では「Docker を正しく理解する」→「Docker Compose に置き換えて楽をする」という流れで導入し、最終的にはとても複雑な構成を `docker compose up` のみで即時起動できる状態を目指します。

## Kubernetes
Kubernetes は `todo` を書くことにより、同じコンテナを複数台起動してクラスタを構築したり、コンテナが意図せず停止してしまった時に自動で再起動をしたりするために導入するオーケストレーションソフトウェアです。

![image](/images/picture/picture.023.jpeg)

Kubernetes も Docker Desktop に含まれており、`todo` のようなコマンド体系になっています。

開発環境を構築する場合、大抵は DB サーバを冗長構成にしたり Web サーバの監視を行ったりはしないので、Kubernetes は使いません。

Docker 利用の主目的を開発環境の構築とするならば、Kubernetes はまだ学ばないと割り切ってしまってもよいでしょう。

この本では Kubernetes については解説を行いません。

# まとめ
長くなってしまったので、簡潔にまとめます。

1. 基本の要素
   - **コンテナ** はホストマシン上の隔離されたプロセス
   - **イメージ** はレイヤーというメタ情報の集積で、Docker Hub などで公開される
   - **Dockerfile** はイメージにレイヤーを重ねるテキストファイルで、GitHub などで共有する
2. 基本のコマンド
    - **コンテナ** を **起動** する
    - **イメージ** を **作成** する
    - **コンテナ** を **操作** する
3. コマンドの形
    - **なに** を **どうする** かの意識が一番大事
    - 理解しやすい **新コマンド** と、短くかける **旧コマンド** がある
4. Docker の周辺知識
    - **Docker Compose** はコンテナをまとめて起動するツールで、開発環境の構築に便利
    - **Kubernetes** はコンテナを運用するツールで、インフラ構築に便利
      
混乱してしまった時は立ち返ってみてください。
